ğŸ“„ Backend Requirements Document

1. ğŸ¯ Objective

Develop a backend framework that enables real-time, multi-turn conversations between a user and LLM agents, orchestrated using LangGraph, and delivered via a WebSocket stream to the frontend. The system must support memory, retrieval, tool access, and token-wise response delivery.

2. ğŸ§  System Components

2.1 FastAPI Server
	â€¢	Accepts WebSocket connections at /ws/chat
	â€¢	Routes user messages to LangGraph
	â€¢	Streams assistant responses back over the same socket

2.2 LangGraph Workflow
	â€¢	Directed, stateful agent flow
	â€¢	Each node is:
	â€¢	A single LangChain Runnable (RunnableSequence, RunnableLambda, etc.)
	â€¢	May read/write from shared memory
	â€¢	Supports branching, looping, and post-processing logic

2.3 Qdrant Vector Store
	â€¢	Stores document embeddings
	â€¢	Used via retriever node for context-augmented response
	â€¢	Supports metadata filtering and scoring

3. âš™ï¸ Functional Requirements

3.1 WebSocket Endpoint
	â€¢	Route: GET /ws/chat
	â€¢	Accepts prompt, session_id, and optional metadata
	â€¢	Maintains open stream during message generation
	â€¢	Emits {"role": "assistant", "content": "<token>"} JSON chunks
	â€¢	Emits {"type": "done"} on generation complete

3.2 LangGraph Agent Workflow
	â€¢	LLM node: Generates assistant reply using ChatOpenAI
	â€¢	Retriever node: Looks up documents from Qdrant (based on user input)
	â€¢	Decision node: Determines if loop or stop
	â€¢	Shared memory:
	â€¢	input_history: For context preservation
	â€¢	retrieved_docs: Optional, for transparency
	â€¢	Modular: easy to add tool usage, validation, or summarization nodes

3.3 Streaming Integration
	â€¢	Use AsyncIteratorCallbackHandler to receive LLM output chunks
	â€¢	Push each token/partial string back to frontend over WebSocket
	â€¢	Handle early disconnect, cancellation (e.g., /abort event)

4. ğŸ“‚ Backend Folder Structure

/backend/app/
â”‚
â”œâ”€â”€ routes/
â”‚   â””â”€â”€ websocket.py         # WebSocket endpoint
â”‚
â”œâ”€â”€ graph/
â”‚   â””â”€â”€ chatbot_graph.py     # LangGraph workflow builder
â”‚
â”œâ”€â”€ chains/
â”‚   â”œâ”€â”€ retriever.py         # Qdrant retriever setup
â”‚   â””â”€â”€ prompts.py           # Prompt templates (system/user)
â”‚
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ streaming.py         # LangChain token streaming handler
â”‚
â””â”€â”€ main.py                  # FastAPI app entry


5. ğŸ” Security & Resilience

Concern	Handling Strategy
WebSocket drops	Catch and terminate LangGraph run cleanly
Rate limiting	Optional (per IP or token)
Secrets management	Use os.environ or config loader (e.g., pydantic.BaseSettings)
Unsafe prompts	Add guardrails node (future)


â¸»

6. ğŸ”„ Event Protocol over WebSocket

Inbound:

{
  "type": "user_message",
  "content": "Tell me about GPT-4",
  "session_id": "abc123"
}

Outbound (token stream):

{ "role": "assistant", "content": "Sure," }
{ "role": "assistant", "content": " GPT-4 is an advanced..." }
...
{ "type": "done" }


7. ğŸ§ª Dev and Testing Guidelines

Area	Recommendation
LLM mocking	Use dummy RunnableLambda in dev
Graph testing	Simulate node execution with fixed input
Socket testing	Use test client (e.g. websocat, socket.io, Cypress)
Timeout recovery	Set max generation time + abort logic


8. ğŸ§± Base Dependencies (requirements.txt)

fastapi
uvicorn
langchain
langgraph
qdrant-client
openai
tiktoken
websockets


9. ğŸš€ Future Enhancements
	â€¢	Multiple agent personas (e.g. Assistant, Planner, Critic)
	â€¢	Tool-use node (code interpreter, browser, calculator)
	â€¢	Session transcript logging (e.g. to SQLite or Supabase)
	â€¢	Prompt adaptation based on user role or history
	â€¢	GroupChat-style agent graph inside LangGraph
